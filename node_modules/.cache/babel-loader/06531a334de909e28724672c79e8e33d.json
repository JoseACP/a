{"ast":null,"code":"import { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nconst generators = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n\nconst percentToProgress = percent => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\n\n\nclass MainThreadAnimation extends BaseAnimation {\n  constructor(_ref) {\n    let {\n      KeyframeResolver: KeyframeResolver$1 = KeyframeResolver,\n      ...options\n    } = _ref;\n    super(options);\n    /**\n     * The time at which the animation was paused.\n     */\n\n    this.holdTime = null;\n    /**\n     * The time at which the animation was started.\n     */\n\n    this.startTime = null;\n    /**\n     * The time at which the animation was cancelled.\n     */\n\n    this.cancelTime = null;\n    /**\n     * The current time of the animation.\n     */\n\n    this.currentTime = 0;\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n\n    this.playbackSpeed = 1;\n    /**\n     * The state of the animation to apply when the animation is resolved. This\n     * allows calls to the public API to control the animation before it is resolved,\n     * without us having to resolve it first.\n     */\n\n    this.pendingPlayState = \"running\";\n    this.state = \"idle\";\n    const {\n      name,\n      motionValue,\n      keyframes\n    } = this.options;\n\n    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n\n    if (name && motionValue && motionValue.owner) {\n      this.resolver = motionValue.owner.resolveKeyframes(keyframes, onResolved, name, motionValue);\n    } else {\n      this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue);\n    }\n\n    this.resolver.scheduleResolve();\n  }\n\n  initPlayback(keyframes$1) {\n    const {\n      type = \"keyframes\",\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType,\n      velocity = 0\n    } = this.options;\n    const generatorFactory = generators[type] || keyframes;\n    /**\n     * If our generator doesn't support mixing numbers, we need to replace keyframes with\n     * [0, 100] and then make a function that maps that to the actual keyframes.\n     *\n     * 100 is chosen instead of 1 as it works nicer with spring animations.\n     */\n\n    let mapPercentToKeyframes;\n    let mirroredGenerator;\n\n    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n      if (process.env.NODE_ENV !== \"production\") {\n        invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n      }\n\n      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n      keyframes$1 = [0, 100];\n    }\n\n    const generator = generatorFactory({ ...this.options,\n      keyframes: keyframes$1\n    });\n    /**\n     * If we have a mirror repeat type we need to create a second generator that outputs the\n     * mirrored (not reversed) animation and later ping pong between the two generators.\n     */\n\n    if (repeatType === \"mirror\") {\n      mirroredGenerator = generatorFactory({ ...this.options,\n        keyframes: [...keyframes$1].reverse(),\n        velocity: -velocity\n      });\n    }\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n\n\n    if (generator.calculatedDuration === null) {\n      generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n\n    const {\n      calculatedDuration\n    } = generator;\n    const resolvedDuration = calculatedDuration + repeatDelay;\n    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    return {\n      generator,\n      mirroredGenerator,\n      mapPercentToKeyframes,\n      calculatedDuration,\n      resolvedDuration,\n      totalDuration\n    };\n  }\n\n  onPostResolved() {\n    const {\n      autoplay = true\n    } = this.options;\n    this.play();\n\n    if (this.pendingPlayState === \"paused\" || !autoplay) {\n      this.pause();\n    } else {\n      this.state = this.pendingPlayState;\n    }\n  }\n\n  tick(timestamp) {\n    let sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      resolved\n    } = this; // If the animations has failed to resolve, return the final keyframe.\n\n    if (!resolved) {\n      const {\n        keyframes\n      } = this.options;\n      return {\n        done: true,\n        value: keyframes[keyframes.length - 1]\n      };\n    }\n\n    const {\n      finalKeyframe,\n      generator,\n      mirroredGenerator,\n      mapPercentToKeyframes,\n      keyframes,\n      calculatedDuration,\n      totalDuration,\n      resolvedDuration\n    } = resolved;\n    if (this.startTime === null) return generator.next(0);\n    const {\n      delay,\n      repeat,\n      repeatType,\n      repeatDelay,\n      onUpdate\n    } = this.options;\n    /**\n     * requestAnimationFrame timestamps can come through as lower than\n     * the startTime as set by performance.now(). Here we prevent this,\n     * though in the future it could be possible to make setting startTime\n     * a pending operation that gets resolved here.\n     */\n\n    if (this.speed > 0) {\n      this.startTime = Math.min(this.startTime, timestamp);\n    } else if (this.speed < 0) {\n      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n    } // Update currentTime\n\n\n    if (sample) {\n      this.currentTime = timestamp;\n    } else if (this.holdTime !== null) {\n      this.currentTime = this.holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n    } // Rebase on delay\n\n\n    const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    this.currentTime = Math.max(timeWithoutDelay, 0); // If this animation has finished, set the current time  to the total duration.\n\n    if (this.state === \"finished\" && this.holdTime === null) {\n      this.currentTime = totalDuration;\n    }\n\n    let elapsed = this.currentTime;\n    let frameGenerator = generator;\n\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n\n      const isOddIteration = Boolean(currentIteration % 2);\n\n      if (isOddIteration) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n\n      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n    }\n    /**\n     * If we're in negative time, set state as the initial keyframe.\n     * This prevents delay: x, duration: 0 animations from finishing\n     * instantly.\n     */\n\n\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes[0]\n    } : frameGenerator.next(elapsed);\n\n    if (mapPercentToKeyframes) {\n      state.value = mapPercentToKeyframes(state.value);\n    }\n\n    let {\n      done\n    } = state;\n\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n    }\n\n    const isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n\n    if (isAnimationFinished && finalKeyframe !== undefined) {\n      state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n    }\n\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n\n    if (isAnimationFinished) {\n      this.finish();\n    }\n\n    return state;\n  }\n\n  get duration() {\n    const {\n      resolved\n    } = this;\n    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n  }\n\n  get time() {\n    return millisecondsToSeconds(this.currentTime);\n  }\n\n  set time(newTime) {\n    newTime = secondsToMilliseconds(newTime);\n    this.currentTime = newTime;\n\n    if (this.holdTime !== null || this.speed === 0) {\n      this.holdTime = newTime;\n    } else if (this.driver) {\n      this.startTime = this.driver.now() - newTime / this.speed;\n    }\n  }\n\n  get speed() {\n    return this.playbackSpeed;\n  }\n\n  set speed(newSpeed) {\n    const hasChanged = this.playbackSpeed !== newSpeed;\n    this.playbackSpeed = newSpeed;\n\n    if (hasChanged) {\n      this.time = millisecondsToSeconds(this.currentTime);\n    }\n  }\n\n  play() {\n    if (!this.resolver.isScheduled) {\n      this.resolver.resume();\n    }\n\n    if (!this._resolved) {\n      this.pendingPlayState = \"running\";\n      return;\n    }\n\n    if (this.isStopped) return;\n    const {\n      driver = frameloopDriver,\n      onPlay\n    } = this.options;\n\n    if (!this.driver) {\n      this.driver = driver(timestamp => this.tick(timestamp));\n    }\n\n    onPlay && onPlay();\n    const now = this.driver.now();\n\n    if (this.holdTime !== null) {\n      this.startTime = now - this.holdTime;\n    } else if (!this.startTime || this.state === \"finished\") {\n      this.startTime = now;\n    }\n\n    if (this.state === \"finished\") {\n      this.updateFinishedPromise();\n    }\n\n    this.cancelTime = this.startTime;\n    this.holdTime = null;\n    /**\n     * Set playState to running only after we've used it in\n     * the previous logic.\n     */\n\n    this.state = \"running\";\n    this.driver.start();\n  }\n\n  pause() {\n    var _a;\n\n    if (!this._resolved) {\n      this.pendingPlayState = \"paused\";\n      return;\n    }\n\n    this.state = \"paused\";\n    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n  }\n\n  stop() {\n    this.resolver.cancel();\n    this.isStopped = true;\n    if (this.state === \"idle\") return;\n    this.teardown();\n    const {\n      onStop\n    } = this.options;\n    onStop && onStop();\n  }\n\n  complete() {\n    if (this.state !== \"running\") {\n      this.play();\n    }\n\n    this.pendingPlayState = this.state = \"finished\";\n    this.holdTime = null;\n  }\n\n  finish() {\n    this.teardown();\n    this.state = \"finished\";\n    const {\n      onComplete\n    } = this.options;\n    onComplete && onComplete();\n  }\n\n  cancel() {\n    if (this.cancelTime !== null) {\n      this.tick(this.cancelTime);\n    }\n\n    this.teardown();\n    this.updateFinishedPromise();\n  }\n\n  teardown() {\n    this.state = \"idle\";\n    this.stopDriver();\n    this.resolveFinishedPromise();\n    this.updateFinishedPromise();\n    this.startTime = this.cancelTime = null;\n    this.resolver.cancel();\n  }\n\n  stopDriver() {\n    if (!this.driver) return;\n    this.driver.stop();\n    this.driver = undefined;\n  }\n\n  sample(time) {\n    this.startTime = 0;\n    return this.tick(time, true);\n  }\n\n} // Legacy interface\n\n\nfunction animateValue(options) {\n  return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };","map":{"version":3,"names":["KeyframeResolver","spring","inertia","keyframes","BaseAnimation","pipe","mix","calcGeneratorDuration","millisecondsToSeconds","secondsToMilliseconds","clamp","invariant","frameloopDriver","getFinalKeyframe","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","constructor","KeyframeResolver$1","options","holdTime","startTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","state","name","motionValue","onResolved","resolvedKeyframes","finalKeyframe","onKeyframesResolved","owner","resolver","resolveKeyframes","scheduleResolve","initPlayback","keyframes$1","type","repeat","repeatDelay","repeatType","velocity","generatorFactory","mapPercentToKeyframes","mirroredGenerator","process","env","NODE_ENV","length","generator","reverse","calculatedDuration","resolvedDuration","totalDuration","onPostResolved","autoplay","play","pause","tick","timestamp","sample","resolved","done","value","next","delay","onUpdate","speed","Math","min","round","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","isAnimationFinished","undefined","finish","duration","time","newTime","driver","now","newSpeed","hasChanged","isScheduled","resume","_resolved","isStopped","onPlay","updateFinishedPromise","start","_a","stop","cancel","teardown","onStop","complete","onComplete","stopDriver","resolveFinishedPromise","animateValue"],"sources":["/Users/pepe/Documents/signin/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs"],"sourcesContent":["import { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor({ KeyframeResolver: KeyframeResolver$1 = KeyframeResolver, ...options }) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = \"running\";\n        this.state = \"idle\";\n        const { name, motionValue, keyframes } = this.options;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        if (name && motionValue && motionValue.owner) {\n            this.resolver = motionValue.owner.resolveKeyframes(keyframes, onResolved, name, motionValue);\n        }\n        else {\n            this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue);\n        }\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            if (process.env.NODE_ENV !== \"production\") {\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n            }\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime || this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.teardown();\n        const { onStop } = this.options;\n        onStop && onStop();\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}